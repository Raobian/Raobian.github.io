<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[leveldb之Slice]]></title>
    <url>%2F2018%2F06%2F25%2Fleveldb%E4%B9%8BSlice%2F</url>
    <content type="text"><![CDATA[LevelDB 中的字符串没有使用 std:string，而是使用Slice。题外话，redis没有使用C语言中的字符串，而是自己构建了SDS这样一种简单动态字符串。Slice include/leveldb/Slice.h 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class LEVELDB_EXPORT Slice &#123; public: // 构造函数 创建空的slice // Create an empty slice. Slice() : data_(&quot;&quot;), size_(0) &#123; &#125; // 构造函数 使用d[0, n - 1] 构造 // Create a slice that refers to d[0,n-1]. Slice(const char* d, size_t n) : data_(d), size_(n) &#123; &#125; // 构造函数 使用C++ string 构造 // Create a slice that refers to the contents of &quot;s&quot; Slice(const std::string&amp; s) : data_(s.data()), size_(s.size()) &#123; &#125; // 构造函数 使用指定长度字符串指针 构造 // Create a slice that refers to s[0,strlen(s)-1] Slice(const char* s) : data_(s), size_(strlen(s)) &#123; &#125; // 采用默认拷贝构造，直接赋值 // Intentionally copyable. Slice(const Slice&amp;) = default; Slice&amp; operator=(const Slice&amp;) = default; // ========== 常用函数 =========== // 返回字符串指针 // Return a pointer to the beginning of the referenced data const char* data() const &#123; return data_; &#125; // 返回数据长度 // Return the length (in bytes) of the referenced data size_t size() const &#123; return size_; &#125; // 是否为空 // Return true iff the length of the referenced data is zero bool empty() const &#123; return size_ == 0; &#125; // 重载[]，通过slice[n]返回第n个字符 // Return the ith byte in the referenced data. // REQUIRES: n &lt; size() char operator[](size_t n) const &#123; assert(n &lt; size()); return data_[n]; &#125; // 清空 // Change this slice to refer to an empty array void clear() &#123; data_ = &quot;&quot;; size_ = 0; &#125; // 去除前缀n个字符 // Drop the first &quot;n&quot; bytes from this slice. void remove_prefix(size_t n) &#123; assert(n &lt;= size()); data_ += n; size_ -= n; &#125; // string 转化 // Return a string that contains the copy of the referenced data. std::string ToString() const &#123; return std::string(data_, size_); &#125; // 比较 // Three-way comparison. Returns value: // &lt; 0 iff &quot;*this&quot; &lt; &quot;b&quot;, // == 0 iff &quot;*this&quot; == &quot;b&quot;, // &gt; 0 iff &quot;*this&quot; &gt; &quot;b&quot; int compare(const Slice&amp; b) const; // 是否以slice x为前缀 // Return true iff &quot;x&quot; is a prefix of &quot;*this&quot; bool starts_with(const Slice&amp; x) const &#123; return ((size_ &gt;= x.size_) &amp;&amp; (memcmp(data_, x.data_, x.size_) == 0)); &#125; private: const char* data_; // 数据指针 size_t size_; // 数据长度&#125; 123456789101112131415161718192021// 重载==操作符，用于判断两个Slice是否相等inline bool operator==(const Slice&amp; x, const Slice&amp; y) &#123; return ((x.size() == y.size()) &amp;&amp; (memcmp(x.data(), y.data(), x.size()) == 0));&#125;// 重载!=操作符，用于判断两个Slice是否不等inline bool operator!=(const Slice&amp; x, const Slice&amp; y) &#123; return !(x == y);&#125;// 比较函数实现inline int Slice::compare(const Slice&amp; b) const &#123; const size_t min_len = (size_ &lt; b.size_) ? size_ : b.size_; int r = memcmp(data_, b.data_, min_len); if (r == 0) &#123; if (size_ &lt; b.size_) r = -1; else if (size_ &gt; b.size_) r = +1; &#125; return r;&#125; 简单使用 12345678910//声明定义一个空字符串Slice slice；//字符串指针初始化SliceSlice s1 = &quot;hello&quot;;const char* p=&quot;world&quot;Slice s2(p);//获取Slice的字符串s2.data();//获取Slice字符串的长度s2.size() ==注意：== 使用Slice时需要格外小心，因为Slice引用的外部数组是由Slice的使用者保证在Slice的生命周期内外部数组是有效的。比如下面的代码中存在bug： 123456Slice slice; if (...) &#123; std::string str = ...; slice = str; &#125; Use(slice); 当if语句的作用域结束时，str会被析构，slice指向的外部空间就不存在了。]]></content>
      <categories>
        <category>leveldb</category>
      </categories>
      <tags>
        <tag>leveldb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leveldb安装与使用]]></title>
    <url>%2F2018%2F06%2F22%2Fleveldb%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[leveldb Google C++ kv数据库。代码风格优秀。涉及到了skip list、内存KV table、LRU cache管理、table文件存储、operation log系统等。 安装下载1git clone https://github.com/google/leveldb.git 编译 安装123mkdir -p build &amp;&amp; cd buildcmake -DCMAKE_BUILD_TYPE=Release .. &amp;&amp; cmake --build .make &amp;&amp; make install 使用hello_leveldb.cc 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;cassert&gt;#include &lt;cstdlib&gt;#include &lt;string&gt;#include &lt;leveldb/db.h&gt;using namespace std;int main(void)&#123; leveldb::DB *db = nullptr; leveldb::Options options; // 如果数据库不存在就创建 options.create_if_missing = true; // 创建的数据库 /tmp/testdb leveldb::Status status = leveldb::DB::Open(options, &quot;/tmp/testdb&quot;, &amp;db); assert(status.ok()); string key = &quot;akey&quot;; string value = &quot;avalue&quot;; string gvalue; // Put leveldb::Status s = db-&gt;Put(leveldb::WriteOptions(), key, value); if (!s.ok()) &#123; // 写入失败 cout &lt;&lt; s.ToString() &lt;&lt; endl; return 0; &#125; // Get s = db-&gt;Get(leveldb::ReadOptions(), key, &amp;gvalue); cout &lt;&lt; (s.ok() ? gvalue : s.ToString()) &lt;&lt; endl; delete db; return 0;&#125; 编译1g++ hello_leveldb.cc -o test -lpthread -lleveldb 运行结果12# ./testavalue 只做了简单的put get操作，还有delete、snapshot等操作。]]></content>
      <categories>
        <category>leveldb</category>
      </categories>
      <tags>
        <tag>leveldb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F06%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to 老边’blog]]></content>
  </entry>
</search>
