<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[leveldb之SkipList]]></title>
    <url>%2F2018%2F06%2F26%2Fleveldb%E4%B9%8BSkipList%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>leveldb</category>
      </categories>
      <tags>
        <tag>leveldb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leveldb之Arena]]></title>
    <url>%2F2018%2F06%2F26%2Fleveldb%E4%B9%8BArena%2F</url>
    <content type="text"><![CDATA[Arena 内存池，避免频繁的new/delete，减少内存申请和释放的开销。模型如下 成员变量123456789// Allocation statechar* alloc_ptr_; // 内存偏移，指向未使用内存首地址size_t alloc_bytes_remaining_; // 剩余已申请的内存// Array of new[] allocated memory blocksstd::vector&lt;char*&gt; blocks_; // 记录每个block的首地址// Total memory usage of the arena.port::AtomicPointer memory_usage_; // 已使用内存大小 构造析构1234567891011Arena::Arena() : memory_usage_(0) &#123; alloc_ptr_ = nullptr; // First allocation will allocate a block alloc_bytes_remaining_ = 0; // vector会调用默认构造函数初始化&#125;Arena::~Arena() &#123; for (size_t i = 0; i &lt; blocks_.size(); i++) &#123; delete[] blocks_[i]; &#125;&#125; 不允许拷贝构造和 =赋值123// No copying allowedArena(const Arena&amp;);void operator=(const Arena&amp;); 申请内存block大小1static const int kBlockSize = 4096; 声明1234567891011// 申请内存// Return a pointer to a newly allocated memory block of &quot;bytes&quot; bytes.char* Allocate(size_t bytes);// 申请内存对齐// Allocate memory with the normal alignment guarantees provided by mallocchar* AllocateAligned(size_t bytes);private:char* AllocateFallback(size_t bytes);char* AllocateNewBlock(size_t block_bytes); 实现过程中分三种情况： 剩余内存足够，直接使用剩余内存分配 剩余内存不足，且申请空间 &gt; kBlockSize/4时，申请一个本次申请大小的block 剩余内存不足，且申请空间 &lt;= kBlockSize/4时，申请一个kBlockSize大小的block 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 分配内存inline char* Arena::Allocate(size_t bytes) &#123; // The semantics of what to return are a bit messy if we allow // 0-byte allocations, so we disallow them here (we don&apos;t need // them for our internal use). assert(bytes &gt; 0); // 1.剩余内存足够，直接使用剩余内存分配 if (bytes &lt;= alloc_bytes_remaining_) &#123; char* result = alloc_ptr_; alloc_ptr_ += bytes; alloc_bytes_remaining_ -= bytes; return result; &#125; return AllocateFallback(bytes);&#125;char* Arena::AllocateFallback(size_t bytes) &#123; // 2.剩余内存不足，且申请空间 &gt; kBlockSize/4时，申请一个本次申请大小的block if (bytes &gt; kBlockSize / 4) &#123; // Object is more than a quarter of our block size. Allocate it separately // to avoid wasting too much space in leftover bytes. char* result = AllocateNewBlock(bytes); return result; &#125; // 3.剩余内存不足，且申请空间 &lt;= kBlockSize/4时，申请一个kBlockSize大小的block // We waste the remaining space in the current block. alloc_ptr_ = AllocateNewBlock(kBlockSize); alloc_bytes_remaining_ = kBlockSize; char* result = alloc_ptr_; alloc_ptr_ += bytes; alloc_bytes_remaining_ -= bytes; return result;&#125;// 申请指定大小blockchar* Arena::AllocateNewBlock(size_t block_bytes) &#123; char* result = new char[block_bytes]; blocks_.push_back(result); // 添加到blocks_中 // 更新MemoryUsage = 已申请内存 + 本次申请 + 一个指针大小 memory_usage_.NoBarrier_Store( reinterpret_cast&lt;void*&gt;(MemoryUsage() + block_bytes + sizeof(char*))); return result;&#125; 对齐申请123456789101112131415161718192021222324252627282930char* Arena::AllocateAligned(size_t bytes) &#123; //用于判断对齐的大小，我64位电脑sizeof(void*)=8，不大于8，所以对齐大小为8。 const int align = (sizeof(void*) &gt; 8) ? sizeof(void*) : 8; // 对齐肯定为2的n次幂 如8==1000 &amp; 7==0111 = 0 assert((align &amp; (align-1)) == 0); // Pointer size should be a power of 2 // alloc_ptr_ &amp; (align-1) 相当于对align取模，如9==1001&amp;7==0111 == 9%8 = 1 size_t current_mod = reinterpret_cast&lt;uintptr_t&gt;(alloc_ptr_) &amp; (align-1); // 计算溢出 即额外需要多少补齐 size_t slop = (current_mod == 0 ? 0 : align - current_mod); // 计算申请大小 = 要申请大小 + 补齐字节 size_t needed = bytes + slop; char* result; // 有剩余，直接对齐分配 if (needed &lt;= alloc_bytes_remaining_) &#123; result = alloc_ptr_ + slop; alloc_ptr_ += needed; alloc_bytes_remaining_ -= needed; &#125; else &#123; // 重申申请 总是对齐的 // AllocateFallback always returned aligned memory result = AllocateFallback(bytes); &#125; assert((reinterpret_cast&lt;uintptr_t&gt;(result) &amp; (align-1)) == 0); return result;&#125; 提供MemoryUsage用于查看内存池总容量12345// Returns an estimate of the total memory usage of data allocated// by the arena.size_t MemoryUsage() const &#123; return reinterpret_cast&lt;uintptr_t&gt;(memory_usage_.NoBarrier_Load());&#125;]]></content>
      <categories>
        <category>leveldb</category>
      </categories>
      <tags>
        <tag>leveldb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leveldb之AtomicPointer]]></title>
    <url>%2F2018%2F06%2F26%2Fleveldb%E4%B9%8BAtomicPointer%2F</url>
    <content type="text"><![CDATA[AtomicPointer 原子指针，并不是原子操作指针，因为指针赋值本身就是原子操作。而leveldb中的原子指针，涉及的是无锁编程，无锁编程涉及到内存屏障。 内存屏障 硬件层的内存屏障分为两种：Load Barrier 和 Store Barrier即读屏障和写屏障。 内存屏障有两个作用： 121. 阻止屏障两侧的指令重排序；2. 强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。 对于Load Barrier来说，在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制从新从主内存加载数据； 对于Store Barrier来说，在指令后插入Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。 leveldb中定义内存屏障只贴了x86 linux，其他平台可以参考源码12345678// Gcc on x86#elif defined(ARCH_CPU_X86_FAMILY) &amp;&amp; defined(__GNUC__)inline void MemoryBarrier() &#123; // See http://gcc.gnu.org/ml/gcc/2003-04/msg01180.html for a discussion on // this idiom. Also see http://en.wikipedia.org/wiki/Memory_ordering. __asm__ __volatile__(&quot;&quot; : : : &quot;memory&quot;);&#125;#define LEVELDB_HAVE_MEMORY_BARRIER 这里的volatile主要是用来防止编译器优化的。就是告诉编译器：不要因为性能优化而将这些代码重排，我需要清清爽爽的保持这三块代码块的顺序（代码块内部是否重排不是这里的volatile管辖范围了）。 如果你想实现下面这样的功能，那你可以考虑内存屏障：修改一个内存中的变量之后，其余的 CPU 和 Cache 里面该变量的原始数据失效，必须从内存中重新获取这个变量的值。这保证了这个变量对 CPU 和 Cache 是「可见的」，leveldb 就使用了这个特性 AtomicPointer1234567891011121314151617181920212223242526272829// AtomicPointer built using platform-specific MemoryBarrier().#if defined(LEVELDB_HAVE_MEMORY_BARRIER)class AtomicPointer &#123; private: void* rep_; public: AtomicPointer() &#123; &#125; explicit AtomicPointer(void* p) : rep_(p) &#123;&#125; // 不使用内存屏障的读操作，即不同步的读操作 inline void* NoBarrier_Load() const &#123; return rep_; &#125; // 同上，是不同步的写操作 inline void NoBarrier_Store(void* v) &#123; rep_ = v; &#125; // 使用内存屏障的读操作，即同步读 inline void* Acquire_Load() const &#123; void* result = rep_; // 添加一个内存屏障，后面会有原理介绍 MemoryBarrier(); return result; &#125; // 使用内存屏障的写操作，即同步写 inline void Release_Store(void* v) &#123; MemoryBarrier(); rep_ = v; &#125;&#125;; 无锁编程的概念做一般应用层开发的会较少接触到，因为多线程的时候对共享资源的操作一般是用锁来完成的。锁本身对这个任务完成的很好，但是存在性能的问题，也就是在对性能要求很高的，高并发的场景下，锁会带来性能瓶颈。所以在一些如数据库这样的应用或者linux 内核里经常会看到一些无锁的并发编程。锁是一个高层次的接口，隐藏了很多并发编程时会出现的非常古怪的问题。当不用锁的时候，就要考虑这些问题。主要有两个方面的影响：编译器对指令的排序和cpu对指令的排序。他们排序的目的主要是优化和提高效率。排序的原则是在单核单线程下最终的效果不会发生改变。单核多线程的时候，编译器的乱序就会带来问题，多核的时候，又会涉及cpu对指令的乱序。memory-ordering-at-compile-time和memory-reordering-caught-in-the-act里提到了乱序导致的问题。注意到其中几个成员函数都是inline，如果不是inline，其实没有必要加上内存屏障，因为函数能够提供很强的内存屏障保证。 下面针对Acquire_Load和Release_Store假设一个场景：1234567891011//thread1：Object.var1 = a;Object.var2 = b;Object.var2 = c;atomicpointer.Release_Store(p);//thread2user_pointer = atomicpointer.Acquire_Load();get Object.va1get Object.var2get Object.var3 结合之前的分析，可以很容易明白此时内存屏障保证了在线程1里指针赋值之前对象的所有操作都已经完成，而在线程2里面保证了取出指针后，才会开始获取新的对象内容。这符合程序的顺序逻辑。注意acquire，release模型适合单生产者和单消费者的模型，如果有多个生产者，那么现有的保障是不足的，会涉及到原子性的问题。]]></content>
      <categories>
        <category>leveldb</category>
      </categories>
      <tags>
        <tag>leveldb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leveldb之Status]]></title>
    <url>%2F2018%2F06%2F25%2Fleveldb%E4%B9%8BStatus%2F</url>
    <content type="text"><![CDATA[Status类是函数执行返回状态类，状态主要是用迭代类型enum Code类,12345678enum Code &#123; kOk = 0, kNotFound = 1, kCorruption = 2, kNotSupported = 3, kInvalidArgument = 4, kIOError = 5 &#125;; 枚举code 长度为4 私有变量state_, state_[0..3] 为消息长度 state_[4] 为 返回码 state_[5..] 为消息实体 123456// OK status has a null state_. Otherwise, state_ is a new[] array// of the following form:// state_[0..3] == length of message// state_[4] == code// state_[5..] == messageconst char* state_; 构造声明与实现include/leveldb/Status.h1234567891011121314class LEVELDB_EXPORT Status &#123; public: // 构造 析构 // Create a success status. Status() noexcept : state_(nullptr) &#123; &#125; ~Status() &#123; delete[] state_; &#125; // 深拷贝构造 重载=操作符 Status(const Status&amp; rhs); Status&amp; operator=(const Status&amp; rhs); // 浅拷贝构造 重载=操作符 Status(Status&amp;&amp; rhs) noexcept : state_(rhs.state_) &#123; rhs.state_ = nullptr; &#125; Status&amp; operator=(Status&amp;&amp; rhs) noexcept; 实现12345678910111213141516171819202122// 深拷贝需要重新分配资源inline Status::Status(const Status&amp; rhs) &#123; state_ = (rhs.state_ == nullptr) ? nullptr : CopyState(rhs.state_);&#125;// 重新分配资源inline Status&amp; Status::operator=(const Status&amp; rhs) &#123; // The following condition catches both aliasing (when this == &amp;rhs), // and the common case where both rhs and *this are ok. if (state_ != rhs.state_) &#123; delete[] state_; // 状态不同，并且状态不为nullptr时调用 CopyState state_ = (rhs.state_ == nullptr) ? nullptr : CopyState(rhs.state_); &#125; return *this;&#125;// 直接替换inline Status&amp; Status::operator=(Status&amp;&amp; rhs) noexcept &#123; std::swap(state_, rhs.state_); return *this;&#125; CopyState 函数实现在util/Status.cc1234567const char* Status::CopyState(const char* state) &#123; uint32_t size; memcpy(&amp;size, state, sizeof(size)); // 前4字节为大小 char* result = new char[size + 5]; // 申请空间要加 5字节(长度与code) memcpy(result, state, size + 5); return result;&#125; 几种状态12345678910111213141516171819// Return a success status.static Status OK() &#123; return Status(); &#125;// Return error status of an appropriate type.static Status NotFound(const Slice&amp; msg, const Slice&amp; msg2 = Slice()) &#123; return Status(kNotFound, msg, msg2);&#125;static Status Corruption(const Slice&amp; msg, const Slice&amp; msg2 = Slice()) &#123; return Status(kCorruption, msg, msg2);&#125;static Status NotSupported(const Slice&amp; msg, const Slice&amp; msg2 = Slice()) &#123; return Status(kNotSupported, msg, msg2);&#125;static Status InvalidArgument(const Slice&amp; msg, const Slice&amp; msg2 = Slice()) &#123; return Status(kInvalidArgument, msg, msg2);&#125;static Status IOError(const Slice&amp; msg, const Slice&amp; msg2 = Slice()) &#123; return Status(kIOError, msg, msg2);&#125; 状态判断 123456789101112131415161718// ok状态 state_ == nullptr// Returns true iff the status indicates success.bool ok() const &#123; return (state_ == nullptr); &#125;// Returns true iff the status indicates a NotFound error.bool IsNotFound() const &#123; return code() == kNotFound; &#125;// Returns true iff the status indicates a Corruption error.bool IsCorruption() const &#123; return code() == kCorruption; &#125;// Returns true iff the status indicates an IOError.bool IsIOError() const &#123; return code() == kIOError; &#125;// Returns true iff the status indicates a NotSupportedError.bool IsNotSupportedError() const &#123; return code() == kNotSupported; &#125;// Returns true iff the status indicates an InvalidArgument.bool IsInvalidArgument() const &#123; return code() == kInvalidArgument; &#125; 其他函数123456789101112 // Return a string representation of this status suitable for printing. // Returns the string &quot;OK&quot; for success. std::string ToString() const; // 第4字节为code Code code() const &#123; return (state_ == nullptr) ? kOk : static_cast&lt;Code&gt;(state_[4]); &#125; Status(Code code, const Slice&amp; msg, const Slice&amp; msg2); static const char* CopyState(const char* s);&#125;; 实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//构造 过程 计算长度 申请空间 赋值Status::Status(Code code, const Slice&amp; msg, const Slice&amp; msg2) &#123; assert(code != kOk); // ok状态 status == nullptr const uint32_t len1 = msg.size(); const uint32_t len2 = msg2.size(); const uint32_t size = len1 + (len2 ? (2 + len2) : 0); char* result = new char[size + 5]; memcpy(result, &amp;size, sizeof(size)); result[4] = static_cast&lt;char&gt;(code); memcpy(result + 5, msg.data(), len1); if (len2) &#123; result[5 + len1] = &apos;:&apos;; result[6 + len1] = &apos; &apos;; memcpy(result + 7 + len1, msg2.data(), len2); &#125; state_ = result;&#125;// C++ string 转化std::string Status::ToString() const &#123; if (state_ == nullptr) &#123; return &quot;OK&quot;; &#125; else &#123; char tmp[30]; const char* type; switch (code()) &#123; case kOk: type = &quot;OK&quot;; break; case kNotFound: type = &quot;NotFound: &quot;; break; case kCorruption: type = &quot;Corruption: &quot;; break; case kNotSupported: type = &quot;Not implemented: &quot;; break; case kInvalidArgument: type = &quot;Invalid argument: &quot;; break; case kIOError: type = &quot;IO error: &quot;; break; default: snprintf(tmp, sizeof(tmp), &quot;Unknown code(%d): &quot;, static_cast&lt;int&gt;(code())); type = tmp; break; &#125; std::string result(type); uint32_t length; memcpy(&amp;length, state_, sizeof(length)); result.append(state_ + 5, length); return result; &#125;&#125; 简单使用1.1234Status s;s = descriptor_log_-&gt;AddRecord(record);if (s.ok()) &#123; ... 2.12345Status s = Status::Corruption(&quot;corrupted key for &quot;, user_key);Status::Corruption(&quot;log record too small&quot;); Status s = Status::IOError(&quot;Deleting DB during memtable compaction&quot;); Status::OK() ; s.ToString() ;]]></content>
      <categories>
        <category>leveldb</category>
      </categories>
      <tags>
        <tag>leveldb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leveldb之Slice]]></title>
    <url>%2F2018%2F06%2F25%2Fleveldb%E4%B9%8BSlice%2F</url>
    <content type="text"><![CDATA[LevelDB 中的字符串没有使用 std:string，而是使用Slice。题外话，redis没有使用C语言中的字符串，而是自己构建了SDS这样一种简单动态字符串。Slice include/leveldb/Slice.h1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class LEVELDB_EXPORT Slice &#123; public: // 构造函数 创建空的slice // Create an empty slice. Slice() : data_(&quot;&quot;), size_(0) &#123; &#125; // 构造函数 使用d[0, n - 1] 构造 // Create a slice that refers to d[0,n-1]. Slice(const char* d, size_t n) : data_(d), size_(n) &#123; &#125; // 构造函数 使用C++ string 构造 // Create a slice that refers to the contents of &quot;s&quot; Slice(const std::string&amp; s) : data_(s.data()), size_(s.size()) &#123; &#125; // 构造函数 使用指定长度字符串指针 构造 // Create a slice that refers to s[0,strlen(s)-1] Slice(const char* s) : data_(s), size_(strlen(s)) &#123; &#125; // 采用默认拷贝构造，直接赋值 // Intentionally copyable. Slice(const Slice&amp;) = default; Slice&amp; operator=(const Slice&amp;) = default; // ========== 常用函数 =========== // 返回字符串指针 // Return a pointer to the beginning of the referenced data const char* data() const &#123; return data_; &#125; // 返回数据长度 // Return the length (in bytes) of the referenced data size_t size() const &#123; return size_; &#125; // 是否为空 // Return true iff the length of the referenced data is zero bool empty() const &#123; return size_ == 0; &#125; // 重载[]，通过slice[n]返回第n个字符 // Return the ith byte in the referenced data. // REQUIRES: n &lt; size() char operator[](size_t n) const &#123; assert(n &lt; size()); return data_[n]; &#125; // 清空 // Change this slice to refer to an empty array void clear() &#123; data_ = &quot;&quot;; size_ = 0; &#125; // 去除前缀n个字符 // Drop the first &quot;n&quot; bytes from this slice. void remove_prefix(size_t n) &#123; assert(n &lt;= size()); data_ += n; size_ -= n; &#125; // string 转化 // Return a string that contains the copy of the referenced data. std::string ToString() const &#123; return std::string(data_, size_); &#125; // 比较 // Three-way comparison. Returns value: // &lt; 0 iff &quot;*this&quot; &lt; &quot;b&quot;, // == 0 iff &quot;*this&quot; == &quot;b&quot;, // &gt; 0 iff &quot;*this&quot; &gt; &quot;b&quot; int compare(const Slice&amp; b) const; // 是否以slice x为前缀 // Return true iff &quot;x&quot; is a prefix of &quot;*this&quot; bool starts_with(const Slice&amp; x) const &#123; return ((size_ &gt;= x.size_) &amp;&amp; (memcmp(data_, x.data_, x.size_) == 0)); &#125; private: const char* data_; // 数据指针 size_t size_; // 数据长度&#125; 123456789101112131415161718192021// 重载==操作符，用于判断两个Slice是否相等inline bool operator==(const Slice&amp; x, const Slice&amp; y) &#123; return ((x.size() == y.size()) &amp;&amp; (memcmp(x.data(), y.data(), x.size()) == 0));&#125;// 重载!=操作符，用于判断两个Slice是否不等inline bool operator!=(const Slice&amp; x, const Slice&amp; y) &#123; return !(x == y);&#125;// 比较函数实现inline int Slice::compare(const Slice&amp; b) const &#123; const size_t min_len = (size_ &lt; b.size_) ? size_ : b.size_; int r = memcmp(data_, b.data_, min_len); if (r == 0) &#123; if (size_ &lt; b.size_) r = -1; else if (size_ &gt; b.size_) r = +1; &#125; return r;&#125; 简单使用 12345678910//声明定义一个空字符串Slice slice；//字符串指针初始化SliceSlice s1 = &quot;hello&quot;;const char* p=&quot;world&quot;Slice s2(p);//获取Slice的字符串s2.data();//获取Slice字符串的长度s2.size() ==注意：== 使用Slice时需要格外小心，因为Slice引用的外部数组是由Slice的使用者保证在Slice的生命周期内外部数组是有效的。比如下面的代码中存在bug： 123456Slice slice; if (...) &#123; std::string str = ...; slice = str; &#125; Use(slice); 当if语句的作用域结束时，str会被析构，slice指向的外部空间就不存在了。]]></content>
      <categories>
        <category>leveldb</category>
      </categories>
      <tags>
        <tag>leveldb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leveldb安装与使用]]></title>
    <url>%2F2018%2F06%2F22%2Fleveldb%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[leveldb Google C++ kv数据库。代码风格优秀。涉及到了skip list、内存KV table、LRU cache管理、table文件存储、operation log系统等。 安装下载1git clone https://github.com/google/leveldb.git 编译 安装123mkdir -p build &amp;&amp; cd buildcmake -DCMAKE_BUILD_TYPE=Release .. &amp;&amp; cmake --build .make &amp;&amp; make install 使用hello_leveldb.cc 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;cassert&gt;#include &lt;cstdlib&gt;#include &lt;string&gt;#include &lt;leveldb/db.h&gt;using namespace std;int main(void)&#123; leveldb::DB *db = nullptr; leveldb::Options options; // 如果数据库不存在就创建 options.create_if_missing = true; // 创建的数据库 /tmp/testdb leveldb::Status status = leveldb::DB::Open(options, &quot;/tmp/testdb&quot;, &amp;db); assert(status.ok()); string key = &quot;akey&quot;; string value = &quot;avalue&quot;; string gvalue; // Put leveldb::Status s = db-&gt;Put(leveldb::WriteOptions(), key, value); if (!s.ok()) &#123; // 写入失败 cout &lt;&lt; s.ToString() &lt;&lt; endl; return 0; &#125; // Get s = db-&gt;Get(leveldb::ReadOptions(), key, &amp;gvalue); cout &lt;&lt; (s.ok() ? gvalue : s.ToString()) &lt;&lt; endl; delete db; return 0;&#125; 编译1g++ hello_leveldb.cc -o test -lpthread -lleveldb 运行结果12# ./testavalue 只做了简单的put get操作，还有delete、snapshot等操作。]]></content>
      <categories>
        <category>leveldb</category>
      </categories>
      <tags>
        <tag>leveldb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F06%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to 老边’blog]]></content>
  </entry>
</search>
