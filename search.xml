<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[utils]]></title>
    <url>%2F2018%2F10%2F29%2Futils%2F</url>
    <content type="text"><![CDATA[查看网卡UUID, MAC12345678910UUID: CentOS7: nmcli con show CentOS6: nmcli con list MAC: CentOS7: nmcli dev show CentOS6: nmcli dev list 修改网卡为eth01234vim /etc/default/grub GRUB_CMDLINE_LINUX 添加 net.ifnames=0 biosdevname=0grub2-mkconfig -o /boot/grub2/grub.cfg PS1配置1export PS1=&quot;[\[\e[36;1m\]\t\e[0m \u@\h \W]\\$ &quot; PS1的常用参数以及含义:123456789101112\d ：代表日期，格式为weekday month date，例如：&quot;Mon Aug 1&quot;\H ：完整的主机名称\h ：仅取主机名中的第一个名字\t ：显示时间为24小时格式，如：HH：MM：SS\T ：显示时间为12小时格式\A ：显示时间为24小时格式：HH：MM\u ：当前用户的账号名称\v ：BASH的版本信息\w ：完整的工作目录名称\W ：利用basename取得工作目录名称，只显示最后一个目录名\# ：下达的第几个命令\$ ：提示字符，如果是root用户，提示符为 # ，普通用户则为 $ 1\[\e[字体色号;背景色号m\]........\[\e[0m\] 123456789字体 背景30 40 黑色31 41 红色32 42 绿色33 43 黄色34 44 蓝色35 45 紫红色36 46 青蓝色37 47 白色 git 操作1234567891011git rebase -i origin/master修改commitgit commit --amend继续rebasegit rebase --continue自动合并commitgit commit --fixup git rebase -i --autosquash pick就是cherry-pick reword 就是在cherry-pick的同时你可以编辑commit message，它会在执行的时候跳出一个界面让你编辑信息，当你退出的时候，会继续执行命令 edit 麻烦点，cherry-pick同时 ，会停止，让你编辑信息，完了后，你要用git rebase –continue命令继续执行，相对上面来说有点麻烦，感觉没必要啊。 squash，合并此条记录到前一个记录中，并把commit message也合并进去 。 fixup ，合并此条记录到前一个记录中，但是忽略此条commit message linux监控uptime快速查看机器的负载情况 1分钟、5分钟、15分钟的平均负载情况16:29:00 up 23:52, 6 users, load average: 17.33, 13.04, 11.07 vmstat 1r：等待在CPU资源的进程数free：系统可用内存数si, so：交换区写入和读取的数量us, sy, id, wa, st：这些都代表了CPU时间的消耗 mpstat -P ALL 1每个CPU的占用情况 pidstat 1输出进程的CPU占用率 sar -n DEV 1网络设备的吞吐率 sar -n TCP,ETCP 1active/s：每秒本地发起的TCP连接数，既通过connect调用创建的TCP连接；passive/s：每秒远程发起的TCP连接数，即通过accept调用创建的TCP连接；retrans/s：每秒TCP重传数量； sar怀疑CPU存在瓶颈，可用 sar -u 和 sar -q 等来查看怀疑内存存在瓶颈，可用 sar -B、sar -r 和 sar -W 等来查看怀疑I/O存在瓶颈，可用 sar -b、sar -u 和 sar -d 等来查看 mdadm 命令mdadm –zero-superblock /dev/sdcmdadm -Ds &gt; /etc/mdadm.conf 批量重命名在Debian或者Ubuntu环境下使用的语法是：1rename &apos;s/stringx/stringy/&apos; files 而在CentOS下或者RedHat下是：1rename stringx stringy files 热插拔磁盘获取编号1lsscsi 热插1echo &quot;scsi add-single-device a b c d&quot; &gt;/proc/scsi/scsi 重新扫描12echo &quot;- - -&quot; &gt; /sys/class/scsi_host/host2/scan for i in /sys/class/scsi_host/host*/scan;do echo &quot;- - -&quot; &gt;$i;done 热拔123echo &quot;scsi remove-single-device a b c d&quot; &gt;/proc/scsi/scsi ls /sys/bus/scsi/drivers/sd/2\:0\:1\:0/ echo 1 &gt; /sys/bus/scsi/drivers/sd/2\:0\:1\:0/delete posix_fadvise fallocate fdatasyncposix_fadvisefallocate(fd, FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLEfdatasync 修改文件大小truncate -s fallocate -l valgrindvalgrind –track-fds=yes –leak-check=full –undef-value-errors=yes ./a.out core文件12345ulimit -c unlimited 大小不受限制sysctl kernel.core_pattern | grep &apos;kernel.core_pattern = corepath&apos; &gt; /dev/nullsysctl -e kernel.core_pattern=corepath &gt; /dev/null/etc/sysctl.conf kernel.core_pattern = /opt/core/core-%e-%p-%s/proc/sys/kernel/core_pattern 编译so连接路径-Wl,rpath=&lt;your_lib_dir&gt; 清缓存1234567891011121314151617181920#echo 3 &gt; /proc/sys/vm/drop_caches要达到释放缓存的目的，我们首先需要了解下关键的配置文件/proc/sys/vm/drop_caches。这个文件中记录了缓存释放的参数，默认值为0，也就是不释放缓存。他的值可以为0~3之间的任意数字，代表着不同的含义：0 – 不释放1 – 释放页缓存2 – 释放dentries和inodes3 – 释放所有缓存知道了参数后，我们就可以根据我们的需要，使用下面的指令来进行操作。首先我们需要使用sync指令，将所有未写的系统缓冲区写到磁盘中，包含已修改的 i-node、已延迟的块 I/O 和读写映射文件。否则在释放缓存的过程中，可能会丢失未保存的文件。sync接下来，我们需要将需要的参数写进/proc/sys/vm/drop_caches文件中，比如我们需要释放所有缓存，就输入下面的命令：echo 3 &gt; /proc/sys/vm/drop_caches此指令输入后会立即生效，可以查询现在的可用内存明显的变多了。要查询当前缓存释放的参数，可以输入下面的指令： cat /proc/sys/vm/drop_caches 查看内存条数123456789101112131415161718192021222324查看内存条数命令：dmidecode | grep -A16 &quot;Memory Device$&quot;其中第一行用全局角度描述系统使用的内存状况：total——总物理内存used——已使用内存，一般情况这个值会比较大，因为这个值包括了cache+应用程序使用的内存free——完全未被使用的内存shared——应用程序共享内存buffers——缓存，主要用于目录方面,inode值等（ls大目录可看到这个值增加）cached——缓存，用于已打开的文件note: total=used+free used=buffers+cached (maybe add shared also)第二行描述应用程序的内存使用：前个值表示-buffers/cache——应用程序使用的内存大小，used减去缓存值后个值表示+buffers/cache——所有可供应用程序使用的内存大小，free加上缓存值note: -buffers/cache=used-buffers-cached +buffers/cache=free+buffers+cached第三行表示swap的使用：used——已使用free——未使用]]></content>
      <categories>
        <category>utils</category>
      </categories>
      <tags>
        <tag>utils</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leveldb之MemTable]]></title>
    <url>%2F2018%2F07%2F15%2Fleveldb%E4%B9%8BMemTable%2F</url>
    <content type="text"><![CDATA[lelveldb 模型如图，有数据写入时，先写入oplog，然后写入memtable。当memtable到达一定大小时，会变成immemtable,后台调度会将immemtable中数据刷到磁盘，形成sstable文件，同时生成新的memtable和op log。 私有成员1234567891011struct KeyComparator &#123; const InternalKeyComparator comparator; explicit KeyComparator(const InternalKeyComparator&amp; c) : comparator(c) &#123; &#125; int operator()(const char* a, const char* b) const;&#125;;typedef SkipList&lt;const char*, KeyComparator&gt; Table;KeyComparator comparator_; // 比较器int refs_; // 引用计数器Arena arena_; // 内存池Table table_; // skiplist KeyComparator::operator()1234567int MemTable::KeyComparator::operator()(const char* aptr, const char* bptr) const &#123; // Internal keys are encoded as length-prefixed strings. Slice a = GetLengthPrefixedSlice(aptr); Slice b = GetLengthPrefixedSlice(bptr); return comparator.Compare(a, b);&#125; 构造析构1234567891011121314// refs初始化为0MemTable::MemTable(const InternalKeyComparator&amp; cmp) : comparator_(cmp), refs_(0), table_(comparator_, &amp;arena_) &#123;&#125;MemTable::~MemTable() &#123; assert(refs_ == 0);&#125; // No copying allowed 无拷贝构造 MemTable(const MemTable&amp;); void operator=(const MemTable&amp;); MemTable::Add 添加数据按skiplist key格式填充数据 插入到table中| key size | user_key | seq | type | value size | value |其中key为internal key12345678910111213141516171819202122232425262728 // Add an entry into memtable that maps key to value at the // specified sequence number and with the specified type. // Typically value will be empty if type==kTypeDeletion.void MemTable::Add(SequenceNumber s, ValueType type, const Slice&amp; key, const Slice&amp; value) &#123; // Format of an entry is concatenation of: // key_size : varint32 of internal_key.size() // key bytes : char[internal_key.size()] // value_size : varint32 of value.size() // value bytes : char[value.size()] size_t key_size = key.size(); size_t val_size = value.size(); size_t internal_key_size = key_size + 8; const size_t encoded_len = VarintLength(internal_key_size) + internal_key_size + VarintLength(val_size) + val_size; char* buf = arena_.Allocate(encoded_len); char* p = EncodeVarint32(buf, internal_key_size); memcpy(p, key.data(), key_size); p += key_size; EncodeFixed64(p, (s &lt;&lt; 8) | type); p += 8; p = EncodeVarint32(p, val_size); memcpy(p, value.data(), val_size); assert(p + val_size == buf + encoded_len); table_.Insert(buf);&#125; MemTable::Add 添加数据12345678910111213141516171819202122232425262728293031323334353637383940414243// 找到key 返回true，被删除的数据 status 为NotFound// If memtable contains a value for key, store it in *value and return true.// If memtable contains a deletion for key, store a NotFound() error// in *status and return true.// Else, return false.bool MemTable::Get(const LookupKey&amp; key, std::string* value, Status* s) &#123; Slice memkey = key.memtable_key(); // | size | InternalKey | Table::Iterator iter(&amp;table_); iter.Seek(memkey.data()); // 迭代器查找 if (iter.Valid()) &#123; // entry format is: // klength varint32 // userkey char[klength] // tag uint64 // vlength varint32 // value char[vlength] // Check that it belongs to same user key. We do not check the // sequence number since the Seek() call above should have skipped // all entries with overly large sequence numbers. const char* entry = iter.key(); uint32_t key_length; const char* key_ptr = GetVarint32Ptr(entry, entry+5, &amp;key_length); if (comparator_.comparator.user_comparator()-&gt;Compare( Slice(key_ptr, key_length - 8), key.user_key()) == 0) &#123; // 找到key // Correct user key const uint64_t tag = DecodeFixed64(key_ptr + key_length - 8); switch (static_cast&lt;ValueType&gt;(tag &amp; 0xff)) &#123; case kTypeValue: &#123; // 可用的，拿到data size Slice v = GetLengthPrefixedSlice(key_ptr + key_length); value-&gt;assign(v.data(), v.size()); return true; &#125; case kTypeDeletion: // 被标记删除的 *s = Status::NotFound(Slice()); return true; &#125; &#125; &#125; return false;&#125; 其他方法12345678910111213141516171819202122232425262728 // Increase reference count. void Ref() &#123; ++refs_; &#125; // Drop reference count. Delete if no more references exist. void Unref() &#123; --refs_; assert(refs_ &gt;= 0); if (refs_ &lt;= 0) &#123; delete this; &#125; &#125; // Returns an estimate of the number of bytes of data in use by this // data structure. It is safe to call when MemTable is being modified. size_t MemTable::ApproximateMemoryUsage() &#123; return arena_.MemoryUsage(); &#125; // Return an iterator that yields the contents of the memtable. // // The caller must ensure that the underlying MemTable remains live // while the returned iterator is live. The keys returned by this // iterator are internal keys encoded by AppendInternalKey in the // db/format.&#123;h,cc&#125; module. Iterator* NewIterator();&#125;; MemTableIterator迭代器12345678910111213141516171819202122232425262728293031class MemTableIterator: public Iterator &#123; public: explicit MemTableIterator(MemTable::Table* table) : iter_(table) &#123; &#125; virtual bool Valid() const &#123; return iter_.Valid(); &#125; virtual void Seek(const Slice&amp; k) &#123; iter_.Seek(EncodeKey(&amp;tmp_, k)); &#125; virtual void SeekToFirst() &#123; iter_.SeekToFirst(); &#125; virtual void SeekToLast() &#123; iter_.SeekToLast(); &#125; virtual void Next() &#123; iter_.Next(); &#125; virtual void Prev() &#123; iter_.Prev(); &#125; virtual Slice key() const &#123; return GetLengthPrefixedSlice(iter_.key()); &#125; virtual Slice value() const &#123; Slice key_slice = GetLengthPrefixedSlice(iter_.key()); return GetLengthPrefixedSlice(key_slice.data() + key_slice.size()); &#125; virtual Status status() const &#123; return Status::OK(); &#125; private: MemTable::Table::Iterator iter_; std::string tmp_; // For passing to EncodeKey // No copying allowed MemTableIterator(const MemTableIterator&amp;); void operator=(const MemTableIterator&amp;);&#125;;Iterator* MemTable::NewIterator() &#123; return new MemTableIterator(&amp;table_);&#125; GetLengthPrefixedSlice1234567// 把带有长度的前缀去掉，返回Slice.static Slice GetLengthPrefixedSlice(const char* data) &#123; uint32_t len; const char* p = data; p = GetVarint32Ptr(p, p + 5, &amp;len); // +5: we assume &quot;p&quot; is not corrupted return Slice(p, len);&#125; 123456789// Encode a suitable internal key target for &quot;target&quot; and return it.// Uses *scratch as scratch space, and the returned pointer will point// into this scratch space.static const char* EncodeKey(std::string* scratch, const Slice&amp; target) &#123; scratch-&gt;clear(); PutVarint32(scratch, target.size()); scratch-&gt;append(target.data(), target.size()); return scratch-&gt;data();&#125;]]></content>
      <categories>
        <category>leveldb</category>
      </categories>
      <tags>
        <tag>leveldb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leveldb之key&Comparator]]></title>
    <url>%2F2018%2F07%2F15%2Fleveldb%E4%B9%8Bkey-Comparator%2F</url>
    <content type="text"><![CDATA[leveldb中存在多种keyInternalKey &amp; LookupKeyskip_list_key keyValueType1234enum ValueType &#123; kTypeDeletion = 0x0, //标记删除的 kTypeValue = 0x1&#125;; SequenceNumber123456typedef uint64_t SequenceNumber;// 低八位用于保存type// We leave eight bits empty at the bottom so a type and sequence#// can be packed together into 64-bits.static const SequenceNumber kMaxSequenceNumber = ((0x1ull &lt;&lt; 56) - 1); ParsedInternalKey 解析的内部key，操作使用| user_key | sequence | type |12345678910struct ParsedInternalKey &#123; Slice user_key; SequenceNumber sequence; ValueType type; ParsedInternalKey() &#123; &#125; // Intentionally left uninitialized (for speed) ParsedInternalKey(const Slice&amp; u, const SequenceNumber&amp; seq, ValueType t) : user_key(u), sequence(seq), type(t) &#123; &#125; std::string DebugString() const;&#125;; 转换函数InternalKey1234567891011inline bool ParseInternalKey(const Slice&amp; internal_key, ParsedInternalKey* result) &#123; const size_t n = internal_key.size(); if (n &lt; 8) return false; uint64_t num = DecodeFixed64(internal_key.data() + n - 8); // seq type unsigned char c = num &amp; 0xff; result-&gt;sequence = num &gt;&gt; 8; result-&gt;type = static_cast&lt;ValueType&gt;(c); result-&gt;user_key = Slice(internal_key.data(), n - 8); return (c &lt;= static_cast&lt;unsigned char&gt;(kTypeValue));&#125; InternalKey 内部key 储存使用| user_key | sequence | type |1234567891011121314151617181920212223242526272829// Modules in this directory should keep internal keys wrapped inside// the following class instead of plain strings so that we do not// incorrectly use string comparisons instead of an InternalKeyComparator.class InternalKey &#123; private: std::string rep_; public: InternalKey() &#123; &#125; // Leave rep_ as empty to indicate it is invalid InternalKey(const Slice&amp; user_key, SequenceNumber s, ValueType t) &#123; // AppendInternalKey AppendInternalKey(&amp;rep_, ParsedInternalKey(user_key, s, t)); &#125; void DecodeFrom(const Slice&amp; s) &#123; rep_.assign(s.data(), s.size()); &#125; // assign为string替换方法 Slice Encode() const &#123; assert(!rep_.empty()); return rep_; &#125; Slice user_key() const &#123; return ExtractUserKey(rep_); &#125; void SetFrom(const ParsedInternalKey&amp; p) &#123; rep_.clear(); AppendInternalKey(&amp;rep_, p); &#125; void Clear() &#123; rep_.clear(); &#125; std::string DebugString() const;&#125; AppendInternalKey1234void AppendInternalKey(std::string* result, const ParsedInternalKey&amp; key) &#123; result-&gt;append(key.user_key.data(), key.user_key.size()); // user key PutFixed64(result, PackSequenceAndType(key.sequence, key.type)); // seq type&#125; LookupKey MemTable使用| size | InternalKey |1234567891011121314151617181920212223242526272829303132333435// A helper class useful for DBImpl::Get()class LookupKey &#123; public: // Initialize *this for looking up user_key at a snapshot with // the specified sequence number. LookupKey(const Slice&amp; user_key, SequenceNumber sequence); ~LookupKey(); // Return a key suitable for lookup in a MemTable. Slice memtable_key() const &#123; return Slice(start_, end_ - start_); &#125; // Return an internal key (suitable for passing to an internal iterator) Slice internal_key() const &#123; return Slice(kstart_, end_ - kstart_); &#125; // Return the user key Slice user_key() const &#123; return Slice(kstart_, end_ - kstart_ - 8); &#125; private: // We construct a char array of the form: // klength varint32 &lt;-- start_ // userkey char[klength] &lt;-- kstart_ // tag uint64 // &lt;-- end_ // The array is a suitable MemTable key. // The suffix starting with &quot;userkey&quot; can be used as an InternalKey. const char* start_; const char* kstart_; const char* end_; char space_[200]; // Avoid allocation for short keys // No copying allowed LookupKey(const LookupKey&amp;); void operator=(const LookupKey&amp;);&#125;; SkipList 中的key| key size | user_key | seq | type | value size | value |同时存储了key和value ComparatorComparator为抽象类，默认比较函数为字节比较 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// A Comparator object provides a total order across slices that are// used as keys in an sstable or a database. A Comparator implementation// must be thread-safe since leveldb may invoke its methods concurrently// from multiple threads.// 实现类必须是多线程安全的class LEVELDB_EXPORT Comparator &#123; public: virtual ~Comparator(); // Three-way comparison. Returns value: // &lt; 0 iff &quot;a&quot; &lt; &quot;b&quot;, // == 0 iff &quot;a&quot; == &quot;b&quot;, // &gt; 0 iff &quot;a&quot; &gt; &quot;b&quot; // 比较函数 virtual int Compare(const Slice&amp; a, const Slice&amp; b) const = 0; // The name of the comparator. Used to check for comparator // mismatches (i.e., a DB created with one comparator is // accessed using a different comparator. // // The client of this package should switch to a new name whenever // the comparator implementation changes in a way that will cause // the relative ordering of any two keys to change. // // Names starting with &quot;leveldb.&quot; are reserved and should not be used // by any clients of this package. // 用名字区分comparator // 以&apos;leveldb.&apos;开头被保留，不能被clients使用 virtual const char* Name() const = 0; // Advanced functions: these are used to reduce the space requirements // for internal data structures like index blocks. // If *start &lt; limit, changes *start to a short string in [start,limit). // Simple comparator implementations may return with *start unchanged, // i.e., an implementation of this method that does nothing is correct. // 两个字符串间的最短字符串 virtual void FindShortestSeparator( std::string* start, const Slice&amp; limit) const = 0; // Changes *key to a short string &gt;= *key. // Simple comparator implementations may return with *key unchanged, // i.e., an implementation of this method that does nothing is correct. // 最短的&gt;= *key的字符串 virtual void FindShortSuccessor(std::string* key) const = 0;&#125;;// Return a builtin comparator that uses lexicographic byte-wise// ordering. The result remains the property of this module and// must not be deleted.LEVELDB_EXPORT const Comparator* BytewiseComparator(); 实现类 BytewiseComparatorImpl123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class BytewiseComparatorImpl : public Comparator &#123; public: BytewiseComparatorImpl() &#123; &#125; virtual const char* Name() const &#123; // 命名为 leveldb.BytewiseComparator return &quot;leveldb.BytewiseComparator&quot;; &#125; // 字符串比较直接调用slice的compare方法 virtual int Compare(const Slice&amp; a, const Slice&amp; b) const &#123; return a.compare(b); &#125; // 找到两个字符串间的最短字符串 // 如start=&quot;helloword&quot; limit=&quot;hellwzbdr&quot; 结果将start 改为&quot;hellp&quot; virtual void FindShortestSeparator( std::string* start, const Slice&amp; limit) const &#123; // Find length of common prefix // 首先计算共同前缀字符串的长度 size_t min_length = std::min(start-&gt;size(), limit.size()); size_t diff_index = 0; while ((diff_index &lt; min_length) &amp;&amp; ((*start)[diff_index] == limit[diff_index])) &#123; diff_index++; &#125; // 找到不同index index=4 if (diff_index &gt;= min_length) &#123; // Do not shorten if one string is a prefix of the other // 一个字符串是另一个字符串的前缀，不操作 &#125; else &#123; uint8_t diff_byte = static_cast&lt;uint8_t&gt;((*start)[diff_index]); // start不同位 &lt; 0xff, start不同+1位 &lt; limit不同位 // 如o &lt; 0xff, w &lt; z if (diff_byte &lt; static_cast&lt;uint8_t&gt;(0xff) &amp;&amp; diff_byte + 1 &lt; static_cast&lt;uint8_t&gt;(limit[diff_index])) &#123; (*start)[diff_index]++; start-&gt;resize(diff_index + 1); // start 改为 &quot;hellp&quot; assert(Compare(*start, limit) &lt; 0); &#125; &#125; &#125; virtual void FindShortSuccessor(std::string* key) const &#123; // Find first character that can be incremented // 找到第一个可以++的字符，执行++后，截断字符串； // 如果找不到说明*key的字符都是0xff啊，那就不作修改，直接返回 size_t n = key-&gt;size(); for (size_t i = 0; i &lt; n; i++) &#123; const uint8_t byte = (*key)[i]; if (byte != static_cast&lt;uint8_t&gt;(0xff)) &#123; (*key)[i] = byte + 1; key-&gt;resize(i+1); return; &#125; &#125; // *key is a run of 0xffs. Leave it alone. &#125;&#125;;&#125; // namespacestatic port::OnceType once = LEVELDB_ONCE_INIT;static const Comparator* bytewise;static void InitModule() &#123; bytewise = new BytewiseComparatorImpl;&#125;const Comparator* BytewiseComparator() &#123; port::InitOnce(&amp;once, InitModule); return bytewise;&#125; 实现类 InternalKeyComparator123456789101112131415161718// A comparator for internal keys that uses a specified comparator for// the user key portion and breaks ties by decreasing sequence number.class InternalKeyComparator : public Comparator &#123; private: const Comparator* user_comparator_; // user key的比较函数 public: explicit InternalKeyComparator(const Comparator* c) : user_comparator_(c) &#123; &#125; virtual const char* Name() const; virtual int Compare(const Slice&amp; a, const Slice&amp; b) const; virtual void FindShortestSeparator( std::string* start, const Slice&amp; limit) const; virtual void FindShortSuccessor(std::string* key) const; const Comparator* user_comparator() const &#123; return user_comparator_; &#125; int Compare(const InternalKey&amp; a, const InternalKey&amp; b) const;&#125;; Name123const char* InternalKeyComparator::Name() const &#123; return &quot;leveldb.InternalKeyComparator&quot;;&#125; Compare1234567891011121314151617181920// 先使用user_compair比较user key，不相等就直接返回，// 相等再比较sequence number | value type, 降序// 这里，没有比较后面的value了，因为sequence number是唯一的int InternalKeyComparator::Compare(const Slice&amp; akey, const Slice&amp; bkey) const &#123; // Order by: // increasing user key (according to user-supplied comparator) // decreasing sequence number // decreasing type (though sequence# should be enough to disambiguate) int r = user_comparator_-&gt;Compare(ExtractUserKey(akey), ExtractUserKey(bkey)); if (r == 0) &#123; const uint64_t anum = DecodeFixed64(akey.data() + akey.size() - 8); const uint64_t bnum = DecodeFixed64(bkey.data() + bkey.size() - 8); if (anum &gt; bnum) &#123; r = -1; &#125; else if (anum &lt; bnum) &#123; r = +1; &#125; &#125; return r;&#125; FindShortestSeparator &amp; FindShortSuccessor123456789101112131415161718192021222324252627282930313233343536void InternalKeyComparator::FindShortestSeparator( std::string* start, const Slice&amp; limit) const &#123; // user key // Attempt to shorten the user portion of the key Slice user_start = ExtractUserKey(*start); Slice user_limit = ExtractUserKey(limit); std::string tmp(user_start.data(), user_start.size()); user_comparator_-&gt;FindShortestSeparator(&amp;tmp, user_limit); if (tmp.size() &lt; user_start.size() &amp;&amp; user_comparator_-&gt;Compare(user_start, tmp) &lt; 0) &#123; // 使用最大的sequence number以保证是最新的*start // User key has become shorter physically, but larger logically. // Tack on the earliest possible number to the shortened user key. PutFixed64(&amp;tmp, PackSequenceAndType(kMaxSequenceNumber,kValueTypeForSeek)); assert(this-&gt;Compare(*start, tmp) &lt; 0); assert(this-&gt;Compare(tmp, limit) &lt; 0); start-&gt;swap(tmp); &#125;&#125;// 取出internal key的user key字段，根据internal key字段找到并替换key,如果key被替换了，// 就用新的key更新Internal Key，并使用最大的sequence number。否则保持不变。void InternalKeyComparator::FindShortSuccessor(std::string* key) const &#123; Slice user_key = ExtractUserKey(*key); std::string tmp(user_key.data(), user_key.size()); user_comparator_-&gt;FindShortSuccessor(&amp;tmp); if (tmp.size() &lt; user_key.size() &amp;&amp; user_comparator_-&gt;Compare(user_key, tmp) &lt; 0) &#123; // User key has become shorter physically, but larger logically. // Tack on the earliest possible number to the shortened user key. PutFixed64(&amp;tmp, PackSequenceAndType(kMaxSequenceNumber,kValueTypeForSeek)); assert(this-&gt;Compare(*key, tmp) &lt; 0); key-&gt;swap(tmp); &#125;&#125;]]></content>
      <categories>
        <category>leveldb</category>
      </categories>
      <tags>
        <tag>leveldb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leveldb之SkipList]]></title>
    <url>%2F2018%2F06%2F26%2Fleveldb%E4%B9%8BSkipList%2F</url>
    <content type="text"><![CDATA[Memtable是leveldb的核心之一，而Memtable使用跳表SkipList实现。 skiplist的效率可以和平衡树媲美，平均O(logN)，最坏O(N)的查询效率，但是用skiplist实现比平衡树实现简单，所以很多程序用跳跃链表来代替平衡树。 内存屏障leveldb是支持多线程操作的，但是skiplist并没有使用linux下锁，信号量来实现同步控制，据说是因为锁机制导致某个线程占有资源，其他线程阻塞的情况，导致系统资源利用率降低。所以leveldb采用的是内存屏障来实现同步机制。 内存屏障参考之前文章《leveldb之AtomicPointer》 SkipList先看节点SkipList::Node SkipList::Node123456789101112131415161718192021222324252627282930313233343536373839404142// Implementation details followtemplate&lt;typename Key, class Comparator&gt;struct SkipList&lt;Key,Comparator&gt;::Node &#123; // C++中的explicit关键字只能用于修饰只有一个参数的类构造函数, 它的作用是表明该构造函数是显示的, //而非隐式的, 跟它相对应的另一个关键字是implicit, 意思是隐藏的,类构造函数默认情况下即声明为implicit(隐式). explicit Node(const Key&amp; k) : key(k) &#123; &#125; Key const key; // 封装next[n]的get set方法，内存屏障 // Accessors/mutators for links. Wrapped in methods so we can // add the appropriate barriers as necessary. Node* Next(int n) &#123; assert(n &gt;= 0); // Use an &apos;acquire load&apos; so that we observe a fully initialized // version of the returned Node. return reinterpret_cast&lt;Node*&gt;(next_[n].Acquire_Load()); &#125; void SetNext(int n, Node* x) &#123; assert(n &gt;= 0); // Use a &apos;release store&apos; so that anybody who reads through this // pointer observes a fully initialized version of the inserted node. next_[n].Release_Store(x); &#125; // 无内存屏障set get next[n] // No-barrier variants that can be safely used in a few locations. Node* NoBarrier_Next(int n) &#123; assert(n &gt;= 0); return reinterpret_cast&lt;Node*&gt;(next_[n].NoBarrier_Load()); &#125; void NoBarrier_SetNext(int n, Node* x) &#123; assert(n &gt;= 0); next_[n].NoBarrier_Store(x); &#125; private: // next数组，大小为节点高度，初始只定义0层，其余根据高度来动态申请空间 // Array of length equal to the node height. next_[0] is lowest level link. port::AtomicPointer next_[1];&#125;; SkipList私有变量1234567891011121314151617181920212223private: struct Node; private: enum &#123; kMaxHeight = 12 &#125;; // 定义最大高度 // 比较类 外部传入 // Immutable after construction Comparator const compare_; // arena 外部传入 Arena* const arena_; // Arena used for allocations of nodes // 头结点 Node* const head_; // 当前最大高度，只被Insert修改 // Modified only by Insert(). Read racily by readers, but stale // values are ok. port::AtomicPointer max_height_; // Height of the entire list // 随机数类，插入时 可用于获取一个随机高度 // Read/written only by Insert(). Random rnd_; 构造析构定义12345678// Create a new SkipList object that will use &quot;cmp&quot; for comparing keys,// and will allocate memory using &quot;*arena&quot;. Objects allocated in the arena// must remain allocated for the lifetime of the skiplist object.explicit SkipList(Comparator cmp, Arena* arena);// No copying allowedSkipList(const SkipList&amp;);void operator=(const SkipList&amp;); 实现1234567891011template&lt;typename Key, class Comparator&gt;SkipList&lt;Key,Comparator&gt;::SkipList(Comparator cmp, Arena* arena) : compare_(cmp), arena_(arena), head_(NewNode(0 /* any key will do */, kMaxHeight)), max_height_(reinterpret_cast&lt;void*&gt;(1)), rnd_(0xdeadbeef) &#123; for (int i = 0; i &lt; kMaxHeight; i++) &#123; head_-&gt;SetNext(i, nullptr); &#125;&#125; compare arena 外部传入，头结点为新建key为0，高度为12的Nodelist最大高度初始化为1rnd_ 0xdeadbeef头结点的所有next都指向nullptr123456789// 新建Nodetemplate&lt;typename Key, class Comparator&gt;typename SkipList&lt;Key,Comparator&gt;::Node*SkipList&lt;Key,Comparator&gt;::NewNode(const Key&amp; key, int height) &#123; // 根据 高度 申请空间 char* mem = arena_-&gt;AllocateAligned( sizeof(Node) + sizeof(port::AtomicPointer) * (height - 1)); return new (mem) Node(key);&#125; new (mem) Node(key)为placement new操作，空间申请和销毁需要手动操作 私有方法1234567891011121314151617181920212223242526272829303132// 获取最大高度inline int GetMaxHeight() const &#123; return static_cast&lt;int&gt;( reinterpret_cast&lt;intptr_t&gt;(max_height_.NoBarrier_Load()));&#125;// 获取随机高度int RandomHeight();// key 是否相等bool Equal(const Key&amp; a, const Key&amp; b) const &#123; return (compare_(a, b) == 0); &#125;// key是否在某结点之后// Return true if key is greater than the data stored in &quot;n&quot;bool KeyIsAfterNode(const Key&amp; key, Node* n) const;// 查找每层key的前节点，填充到prev// Return the earliest node that comes at or after key.// Return nullptr if there is no such node.//// If prev is non-null, fills prev[level] with pointer to previous// node at &quot;level&quot; for every level in [0..max_height_-1].Node* FindGreaterOrEqual(const Key&amp; key, Node** prev) const;// 找到一个小于key的节点// Return the latest node with a key &lt; key.// Return head_ if there is no such node.Node* FindLessThan(const Key&amp; key) const;// 最后一个节点// Return the last node in the list.// Return head_ if list is empty.Node* FindLast() const; 1. 产生随机高度，每层1/4概率抽样12345678910111213template&lt;typename Key, class Comparator&gt;int SkipList&lt;Key,Comparator&gt;::RandomHeight() &#123; // 1/4概率抽样 // Increase height with probability 1 in kBranching static const unsigned int kBranching = 4; int height = 1; while (height &lt; kMaxHeight &amp;&amp; ((rnd_.Next() % kBranching) == 0)) &#123; height++; &#125; assert(height &gt; 0); assert(height &lt;= kMaxHeight); return height;&#125; 2. key是否在某结点之后，对比key大小12345template&lt;typename Key, class Comparator&gt;bool SkipList&lt;Key,Comparator&gt;::KeyIsAfterNode(const Key&amp; key, Node* n) const &#123; // null n is considered infinite return (n != nullptr) &amp;&amp; (compare_(n-&gt;key, key) &lt; 0);&#125; 3. 查找每层key的前节点，填充到prev的每一层，返回大于等于key的节点123456789101112131415161718192021template&lt;typename Key, class Comparator&gt;typename SkipList&lt;Key,Comparator&gt;::Node* SkipList&lt;Key,Comparator&gt;::FindGreaterOrEqual(const Key&amp; key, Node** prev) const &#123; Node* x = head_; int level = GetMaxHeight() - 1; while (true) &#123; Node* next = x-&gt;Next(level); if (KeyIsAfterNode(key, next)) &#123; // Keep searching in this list x = next; &#125; else &#123; // x &lt;= key &lt; next if (prev != nullptr) prev[level] = x; // 填充 if (level == 0) &#123; // 查找结束 返回0层下一个节点 return next; &#125; else &#123; // 查找下一层 // Switch to next list level--; &#125; &#125; &#125;&#125; 4. 找到key的前一个节点1234567891011121314151617181920template&lt;typename Key, class Comparator&gt;typename SkipList&lt;Key,Comparator&gt;::Node*SkipList&lt;Key,Comparator&gt;::FindLessThan(const Key&amp; key) const &#123; Node* x = head_; int level = GetMaxHeight() - 1; while (true) &#123; assert(x == head_ || compare_(x-&gt;key, key) &lt; 0); Node* next = x-&gt;Next(level); if (next == nullptr || compare_(next-&gt;key, key) &gt;= 0) &#123; // next &gt;= key &gt; x if (level == 0) &#123; return x; &#125; else &#123; // Switch to next list level--; &#125; &#125; else &#123; x = next; &#125; &#125;&#125; 5. 找到最后一个节点12345678910111213141516171819template&lt;typename Key, class Comparator&gt;typename SkipList&lt;Key,Comparator&gt;::Node* SkipList&lt;Key,Comparator&gt;::FindLast() const &#123; Node* x = head_; int level = GetMaxHeight() - 1; while (true) &#123; Node* next = x-&gt;Next(level); if (next == nullptr) &#123; if (level == 0) &#123; return x; &#125; else &#123; // Switch to next list level--; &#125; &#125; else &#123; x = next; &#125; &#125;&#125; 公共方法12345678 public: // Insert key into the list. // REQUIRES: nothing that compares equal to key is currently in the list. void Insert(const Key&amp; key); // Returns true iff an entry that compares equal to key is in the list. bool Contains(const Key&amp; key) const;&#125;; 1. 插入主要是查找前置节点，并插入到前置节点后边12345678910111213141516171819202122232425262728293031323334353637383940template&lt;typename Key, class Comparator&gt;void SkipList&lt;Key,Comparator&gt;::Insert(const Key&amp; key) &#123; // TODO(opt): We can use a barrier-free variant of FindGreaterOrEqual() // here since Insert() is externally synchronized. Node* prev[kMaxHeight]; // 查找到前置节点到prev，下一个节点为x Node* x = FindGreaterOrEqual(key, prev); // 禁止重复插入 // Our data structure does not allow duplicate insertion assert(x == nullptr || !Equal(key, x-&gt;key)); // 获取随机高度，如果超过当前最大高度，填充prev超出部分为head，更新当前最大高度 int height = RandomHeight(); if (height &gt; GetMaxHeight()) &#123; for (int i = GetMaxHeight(); i &lt; height; i++) &#123; prev[i] = head_; &#125; //fprintf(stderr, &quot;Change height from %d to %d\n&quot;, max_height_, height); // It is ok to mutate max_height_ without any synchronization // with concurrent readers. A concurrent reader that observes // the new value of max_height_ will see either the old value of // new level pointers from head_ (nullptr), or a new value set in // the loop below. In the former case the reader will // immediately drop to the next level since nullptr sorts after all // keys. In the latter case the reader will use the new node. max_height_.NoBarrier_Store(reinterpret_cast&lt;void*&gt;(height)); &#125; // 新建节点，x-&gt;next = prev-&gt;next, prev-&gt;next = x x = NewNode(key, height); for (int i = 0; i &lt; height; i++) &#123; // NoBarrier_SetNext() suffices since we will add a barrier when // we publish a pointer to &quot;x&quot; in prev[i]. x-&gt;NoBarrier_SetNext(i, prev[i]-&gt;NoBarrier_Next(i)); prev[i]-&gt;SetNext(i, x); &#125;&#125; 2. 包含找到大于等于key的节点，判断key是否相等123456789template&lt;typename Key, class Comparator&gt;bool SkipList&lt;Key,Comparator&gt;::Contains(const Key&amp; key) const &#123; Node* x = FindGreaterOrEqual(key, nullptr); if (x != nullptr &amp;&amp; Equal(key, x-&gt;key)) &#123; return true; &#125; else &#123; return false; &#125;&#125; 迭代器Iterator内部类:内部类就是外部类的友元类。注意友元类的定义，内部类可以通过外部类的对象参数来访问外部类中的所有成员。但是外部类不是内部类的友元。这个内部类是一个独立的类，它不属于外部类，更不能通过外部类的对象去调用内部类。外部类对内部类没有任何优越的访问权限。12345678910111213141516171819202122232425262728293031323334353637383940414243444546// Iteration over the contents of a skip listclass Iterator &#123; public: // 基于list，初始状态为不可用 // Initialize an iterator over the specified list. // The returned iterator is not valid. explicit Iterator(const SkipList* list); // 是否可用 // Returns true iff the iterator is positioned at a valid node. bool Valid() const; // 返回当前位置的key，需要可用状态 // Returns the key at the current position. // REQUIRES: Valid() const Key&amp; key() const; // 跳到下一个位置 // Advances to the next position. // REQUIRES: Valid() void Next(); // 跳到上一个位置 // Advances to the previous position. // REQUIRES: Valid() void Prev(); // 跳到目标位置 // Advance to the first entry with a key &gt;= target void Seek(const Key&amp; target); // 跳到首位 // Position at the first entry in list. // Final state of iterator is Valid() iff list is not empty. void SeekToFirst(); // 跳到末位 // Position at the last entry in list. // Final state of iterator is Valid() iff list is not empty. void SeekToLast(); private: const SkipList* list_; // 要迭代的跳表 Node* node_; // 当前节点 // Intentionally copyable&#125;; 构造12345template&lt;typename Key, class Comparator&gt;inline SkipList&lt;Key,Comparator&gt;::Iterator::Iterator(const SkipList* list) &#123; list_ = list; node_ = nullptr;&#125; 方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 通过当前节点是否有效判断是否可用template&lt;typename Key, class Comparator&gt;inline bool SkipList&lt;Key,Comparator&gt;::Iterator::Valid() const &#123; return node_ != nullptr;&#125;// 返回当前节点keytemplate&lt;typename Key, class Comparator&gt;inline const Key&amp; SkipList&lt;Key,Comparator&gt;::Iterator::key() const &#123; assert(Valid()); return node_-&gt;key;&#125;// 当前节点跳到0层nexttemplate&lt;typename Key, class Comparator&gt;inline void SkipList&lt;Key,Comparator&gt;::Iterator::Next() &#123; assert(Valid()); node_ = node_-&gt;Next(0);&#125;// 当前节点跳到prevtemplate&lt;typename Key, class Comparator&gt;inline void SkipList&lt;Key,Comparator&gt;::Iterator::Prev() &#123; // Instead of using explicit &quot;prev&quot; links, we just search for the // last node that falls before key. assert(Valid()); node_ = list_-&gt;FindLessThan(node_-&gt;key); if (node_ == list_-&gt;head_) &#123; node_ = nullptr; &#125;&#125;// 查找大于等于key的下一个节点template&lt;typename Key, class Comparator&gt;inline void SkipList&lt;Key,Comparator&gt;::Iterator::Seek(const Key&amp; target) &#123; node_ = list_-&gt;FindGreaterOrEqual(target, nullptr);&#125;// 跳到head的0层nexttemplate&lt;typename Key, class Comparator&gt;inline void SkipList&lt;Key,Comparator&gt;::Iterator::SeekToFirst() &#123; node_ = list_-&gt;head_-&gt;Next(0);&#125;// 找到最后节点，跳转template&lt;typename Key, class Comparator&gt;inline void SkipList&lt;Key,Comparator&gt;::Iterator::SeekToLast() &#123; node_ = list_-&gt;FindLast(); if (node_ == list_-&gt;head_) &#123; node_ = nullptr; &#125;&#125;]]></content>
      <categories>
        <category>leveldb</category>
      </categories>
      <tags>
        <tag>leveldb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leveldb之Arena]]></title>
    <url>%2F2018%2F06%2F26%2Fleveldb%E4%B9%8BArena%2F</url>
    <content type="text"><![CDATA[Arena 内存池，避免频繁的new/delete，减少内存申请和释放的开销。模型如下 成员变量123456789// Allocation statechar* alloc_ptr_; // 内存偏移，指向未使用内存首地址size_t alloc_bytes_remaining_; // 剩余已申请的内存// Array of new[] allocated memory blocksstd::vector&lt;char*&gt; blocks_; // 记录每个block的首地址// Total memory usage of the arena.port::AtomicPointer memory_usage_; // 已使用内存大小 构造析构1234567891011Arena::Arena() : memory_usage_(0) &#123; alloc_ptr_ = nullptr; // First allocation will allocate a block alloc_bytes_remaining_ = 0; // vector会调用默认构造函数初始化&#125;Arena::~Arena() &#123; for (size_t i = 0; i &lt; blocks_.size(); i++) &#123; delete[] blocks_[i]; &#125;&#125; 不允许拷贝构造和 =赋值123// No copying allowedArena(const Arena&amp;);void operator=(const Arena&amp;); 申请内存block大小1static const int kBlockSize = 4096; 声明1234567891011// 申请内存// Return a pointer to a newly allocated memory block of &quot;bytes&quot; bytes.char* Allocate(size_t bytes);// 申请内存对齐// Allocate memory with the normal alignment guarantees provided by mallocchar* AllocateAligned(size_t bytes);private:char* AllocateFallback(size_t bytes);char* AllocateNewBlock(size_t block_bytes); 实现过程中分三种情况： 剩余内存足够，直接使用剩余内存分配 剩余内存不足，且申请空间 &gt; kBlockSize/4时，申请一个本次申请大小的block 剩余内存不足，且申请空间 &lt;= kBlockSize/4时，申请一个kBlockSize大小的block 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 分配内存inline char* Arena::Allocate(size_t bytes) &#123; // The semantics of what to return are a bit messy if we allow // 0-byte allocations, so we disallow them here (we don&apos;t need // them for our internal use). assert(bytes &gt; 0); // 1.剩余内存足够，直接使用剩余内存分配 if (bytes &lt;= alloc_bytes_remaining_) &#123; char* result = alloc_ptr_; alloc_ptr_ += bytes; alloc_bytes_remaining_ -= bytes; return result; &#125; return AllocateFallback(bytes);&#125;char* Arena::AllocateFallback(size_t bytes) &#123; // 2.剩余内存不足，且申请空间 &gt; kBlockSize/4时，申请一个本次申请大小的block if (bytes &gt; kBlockSize / 4) &#123; // Object is more than a quarter of our block size. Allocate it separately // to avoid wasting too much space in leftover bytes. char* result = AllocateNewBlock(bytes); return result; &#125; // 3.剩余内存不足，且申请空间 &lt;= kBlockSize/4时，申请一个kBlockSize大小的block // We waste the remaining space in the current block. alloc_ptr_ = AllocateNewBlock(kBlockSize); alloc_bytes_remaining_ = kBlockSize; char* result = alloc_ptr_; alloc_ptr_ += bytes; alloc_bytes_remaining_ -= bytes; return result;&#125;// 申请指定大小blockchar* Arena::AllocateNewBlock(size_t block_bytes) &#123; char* result = new char[block_bytes]; blocks_.push_back(result); // 添加到blocks_中 // 更新MemoryUsage = 已申请内存 + 本次申请 + 一个指针大小 memory_usage_.NoBarrier_Store( reinterpret_cast&lt;void*&gt;(MemoryUsage() + block_bytes + sizeof(char*))); return result;&#125; 对齐申请123456789101112131415161718192021222324252627282930char* Arena::AllocateAligned(size_t bytes) &#123; //用于判断对齐的大小，我64位电脑sizeof(void*)=8，不大于8，所以对齐大小为8。 const int align = (sizeof(void*) &gt; 8) ? sizeof(void*) : 8; // 对齐肯定为2的n次幂 如8==1000 &amp; 7==0111 = 0 assert((align &amp; (align-1)) == 0); // Pointer size should be a power of 2 // alloc_ptr_ &amp; (align-1) 相当于对align取模，如9==1001&amp;7==0111 == 9%8 = 1 size_t current_mod = reinterpret_cast&lt;uintptr_t&gt;(alloc_ptr_) &amp; (align-1); // 计算溢出 即额外需要多少补齐 size_t slop = (current_mod == 0 ? 0 : align - current_mod); // 计算申请大小 = 要申请大小 + 补齐字节 size_t needed = bytes + slop; char* result; // 有剩余，直接对齐分配 if (needed &lt;= alloc_bytes_remaining_) &#123; result = alloc_ptr_ + slop; alloc_ptr_ += needed; alloc_bytes_remaining_ -= needed; &#125; else &#123; // 重申申请 总是对齐的 // AllocateFallback always returned aligned memory result = AllocateFallback(bytes); &#125; assert((reinterpret_cast&lt;uintptr_t&gt;(result) &amp; (align-1)) == 0); return result;&#125; 提供MemoryUsage用于查看内存池总容量12345// Returns an estimate of the total memory usage of data allocated// by the arena.size_t MemoryUsage() const &#123; return reinterpret_cast&lt;uintptr_t&gt;(memory_usage_.NoBarrier_Load());&#125;]]></content>
      <categories>
        <category>leveldb</category>
      </categories>
      <tags>
        <tag>leveldb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leveldb之AtomicPointer]]></title>
    <url>%2F2018%2F06%2F26%2Fleveldb%E4%B9%8BAtomicPointer%2F</url>
    <content type="text"><![CDATA[AtomicPointer 原子指针，并不是原子操作指针，因为指针赋值本身就是原子操作。而leveldb中的原子指针，涉及的是无锁编程，无锁编程涉及到内存屏障。 内存屏障 硬件层的内存屏障分为两种：Load Barrier 和 Store Barrier即读屏障和写屏障。 内存屏障有两个作用： 121. 阻止屏障两侧的指令重排序；2. 强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。 对于Load Barrier来说，在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制从新从主内存加载数据； 对于Store Barrier来说，在指令后插入Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。 leveldb中定义内存屏障只贴了x86 linux，其他平台可以参考源码12345678// Gcc on x86#elif defined(ARCH_CPU_X86_FAMILY) &amp;&amp; defined(__GNUC__)inline void MemoryBarrier() &#123; // See http://gcc.gnu.org/ml/gcc/2003-04/msg01180.html for a discussion on // this idiom. Also see http://en.wikipedia.org/wiki/Memory_ordering. __asm__ __volatile__(&quot;&quot; : : : &quot;memory&quot;);&#125;#define LEVELDB_HAVE_MEMORY_BARRIER 这里的volatile主要是用来防止编译器优化的。就是告诉编译器：不要因为性能优化而将这些代码重排，我需要清清爽爽的保持这三块代码块的顺序（代码块内部是否重排不是这里的volatile管辖范围了）。 如果你想实现下面这样的功能，那你可以考虑内存屏障：修改一个内存中的变量之后，其余的 CPU 和 Cache 里面该变量的原始数据失效，必须从内存中重新获取这个变量的值。这保证了这个变量对 CPU 和 Cache 是「可见的」，leveldb 就使用了这个特性 AtomicPointer1234567891011121314151617181920212223242526272829// AtomicPointer built using platform-specific MemoryBarrier().#if defined(LEVELDB_HAVE_MEMORY_BARRIER)class AtomicPointer &#123; private: void* rep_; public: AtomicPointer() &#123; &#125; explicit AtomicPointer(void* p) : rep_(p) &#123;&#125; // 不使用内存屏障的读操作，即不同步的读操作 inline void* NoBarrier_Load() const &#123; return rep_; &#125; // 同上，是不同步的写操作 inline void NoBarrier_Store(void* v) &#123; rep_ = v; &#125; // 使用内存屏障的读操作，即同步读 inline void* Acquire_Load() const &#123; void* result = rep_; // 添加一个内存屏障，后面会有原理介绍 MemoryBarrier(); return result; &#125; // 使用内存屏障的写操作，即同步写 inline void Release_Store(void* v) &#123; MemoryBarrier(); rep_ = v; &#125;&#125;; 无锁编程的概念做一般应用层开发的会较少接触到，因为多线程的时候对共享资源的操作一般是用锁来完成的。锁本身对这个任务完成的很好，但是存在性能的问题，也就是在对性能要求很高的，高并发的场景下，锁会带来性能瓶颈。所以在一些如数据库这样的应用或者linux 内核里经常会看到一些无锁的并发编程。锁是一个高层次的接口，隐藏了很多并发编程时会出现的非常古怪的问题。当不用锁的时候，就要考虑这些问题。主要有两个方面的影响：编译器对指令的排序和cpu对指令的排序。他们排序的目的主要是优化和提高效率。排序的原则是在单核单线程下最终的效果不会发生改变。单核多线程的时候，编译器的乱序就会带来问题，多核的时候，又会涉及cpu对指令的乱序。memory-ordering-at-compile-time和memory-reordering-caught-in-the-act里提到了乱序导致的问题。注意到其中几个成员函数都是inline，如果不是inline，其实没有必要加上内存屏障，因为函数能够提供很强的内存屏障保证。 下面针对Acquire_Load和Release_Store假设一个场景：1234567891011//thread1：Object.var1 = a;Object.var2 = b;Object.var2 = c;atomicpointer.Release_Store(p);//thread2user_pointer = atomicpointer.Acquire_Load();get Object.va1get Object.var2get Object.var3 结合之前的分析，可以很容易明白此时内存屏障保证了在线程1里指针赋值之前对象的所有操作都已经完成，而在线程2里面保证了取出指针后，才会开始获取新的对象内容。这符合程序的顺序逻辑。注意acquire，release模型适合单生产者和单消费者的模型，如果有多个生产者，那么现有的保障是不足的，会涉及到原子性的问题。]]></content>
      <categories>
        <category>leveldb</category>
      </categories>
      <tags>
        <tag>leveldb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leveldb之Status]]></title>
    <url>%2F2018%2F06%2F25%2Fleveldb%E4%B9%8BStatus%2F</url>
    <content type="text"><![CDATA[Status类是函数执行返回状态类，状态主要是用迭代类型enum Code类,12345678enum Code &#123; kOk = 0, kNotFound = 1, kCorruption = 2, kNotSupported = 3, kInvalidArgument = 4, kIOError = 5 &#125;; 枚举code 长度为4 私有变量state_, state_[0..3] 为消息长度 state_[4] 为 返回码 state_[5..] 为消息实体 123456// OK status has a null state_. Otherwise, state_ is a new[] array// of the following form:// state_[0..3] == length of message// state_[4] == code// state_[5..] == messageconst char* state_; 构造声明与实现include/leveldb/Status.h1234567891011121314class LEVELDB_EXPORT Status &#123; public: // 构造 析构 // Create a success status. Status() noexcept : state_(nullptr) &#123; &#125; ~Status() &#123; delete[] state_; &#125; // 深拷贝构造 重载=操作符 Status(const Status&amp; rhs); Status&amp; operator=(const Status&amp; rhs); // 浅拷贝构造 重载=操作符 Status(Status&amp;&amp; rhs) noexcept : state_(rhs.state_) &#123; rhs.state_ = nullptr; &#125; Status&amp; operator=(Status&amp;&amp; rhs) noexcept; 实现12345678910111213141516171819202122// 深拷贝需要重新分配资源inline Status::Status(const Status&amp; rhs) &#123; state_ = (rhs.state_ == nullptr) ? nullptr : CopyState(rhs.state_);&#125;// 重新分配资源inline Status&amp; Status::operator=(const Status&amp; rhs) &#123; // The following condition catches both aliasing (when this == &amp;rhs), // and the common case where both rhs and *this are ok. if (state_ != rhs.state_) &#123; delete[] state_; // 状态不同，并且状态不为nullptr时调用 CopyState state_ = (rhs.state_ == nullptr) ? nullptr : CopyState(rhs.state_); &#125; return *this;&#125;// 直接替换inline Status&amp; Status::operator=(Status&amp;&amp; rhs) noexcept &#123; std::swap(state_, rhs.state_); return *this;&#125; CopyState 函数实现在util/Status.cc1234567const char* Status::CopyState(const char* state) &#123; uint32_t size; memcpy(&amp;size, state, sizeof(size)); // 前4字节为大小 char* result = new char[size + 5]; // 申请空间要加 5字节(长度与code) memcpy(result, state, size + 5); return result;&#125; 几种状态12345678910111213141516171819// Return a success status.static Status OK() &#123; return Status(); &#125;// Return error status of an appropriate type.static Status NotFound(const Slice&amp; msg, const Slice&amp; msg2 = Slice()) &#123; return Status(kNotFound, msg, msg2);&#125;static Status Corruption(const Slice&amp; msg, const Slice&amp; msg2 = Slice()) &#123; return Status(kCorruption, msg, msg2);&#125;static Status NotSupported(const Slice&amp; msg, const Slice&amp; msg2 = Slice()) &#123; return Status(kNotSupported, msg, msg2);&#125;static Status InvalidArgument(const Slice&amp; msg, const Slice&amp; msg2 = Slice()) &#123; return Status(kInvalidArgument, msg, msg2);&#125;static Status IOError(const Slice&amp; msg, const Slice&amp; msg2 = Slice()) &#123; return Status(kIOError, msg, msg2);&#125; 状态判断 123456789101112131415161718// ok状态 state_ == nullptr// Returns true iff the status indicates success.bool ok() const &#123; return (state_ == nullptr); &#125;// Returns true iff the status indicates a NotFound error.bool IsNotFound() const &#123; return code() == kNotFound; &#125;// Returns true iff the status indicates a Corruption error.bool IsCorruption() const &#123; return code() == kCorruption; &#125;// Returns true iff the status indicates an IOError.bool IsIOError() const &#123; return code() == kIOError; &#125;// Returns true iff the status indicates a NotSupportedError.bool IsNotSupportedError() const &#123; return code() == kNotSupported; &#125;// Returns true iff the status indicates an InvalidArgument.bool IsInvalidArgument() const &#123; return code() == kInvalidArgument; &#125; 其他函数123456789101112 // Return a string representation of this status suitable for printing. // Returns the string &quot;OK&quot; for success. std::string ToString() const; // 第4字节为code Code code() const &#123; return (state_ == nullptr) ? kOk : static_cast&lt;Code&gt;(state_[4]); &#125; Status(Code code, const Slice&amp; msg, const Slice&amp; msg2); static const char* CopyState(const char* s);&#125;; 实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//构造 过程 计算长度 申请空间 赋值Status::Status(Code code, const Slice&amp; msg, const Slice&amp; msg2) &#123; assert(code != kOk); // ok状态 status == nullptr const uint32_t len1 = msg.size(); const uint32_t len2 = msg2.size(); const uint32_t size = len1 + (len2 ? (2 + len2) : 0); char* result = new char[size + 5]; memcpy(result, &amp;size, sizeof(size)); result[4] = static_cast&lt;char&gt;(code); memcpy(result + 5, msg.data(), len1); if (len2) &#123; result[5 + len1] = &apos;:&apos;; result[6 + len1] = &apos; &apos;; memcpy(result + 7 + len1, msg2.data(), len2); &#125; state_ = result;&#125;// C++ string 转化std::string Status::ToString() const &#123; if (state_ == nullptr) &#123; return &quot;OK&quot;; &#125; else &#123; char tmp[30]; const char* type; switch (code()) &#123; case kOk: type = &quot;OK&quot;; break; case kNotFound: type = &quot;NotFound: &quot;; break; case kCorruption: type = &quot;Corruption: &quot;; break; case kNotSupported: type = &quot;Not implemented: &quot;; break; case kInvalidArgument: type = &quot;Invalid argument: &quot;; break; case kIOError: type = &quot;IO error: &quot;; break; default: snprintf(tmp, sizeof(tmp), &quot;Unknown code(%d): &quot;, static_cast&lt;int&gt;(code())); type = tmp; break; &#125; std::string result(type); uint32_t length; memcpy(&amp;length, state_, sizeof(length)); result.append(state_ + 5, length); return result; &#125;&#125; 简单使用1.1234Status s;s = descriptor_log_-&gt;AddRecord(record);if (s.ok()) &#123; ... 2.12345Status s = Status::Corruption(&quot;corrupted key for &quot;, user_key);Status::Corruption(&quot;log record too small&quot;); Status s = Status::IOError(&quot;Deleting DB during memtable compaction&quot;); Status::OK() ; s.ToString() ;]]></content>
      <categories>
        <category>leveldb</category>
      </categories>
      <tags>
        <tag>leveldb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leveldb之Slice]]></title>
    <url>%2F2018%2F06%2F25%2Fleveldb%E4%B9%8BSlice%2F</url>
    <content type="text"><![CDATA[LevelDB 中的字符串没有使用 std:string，而是使用Slice。题外话，redis没有使用C语言中的字符串，而是自己构建了SDS这样一种简单动态字符串。Slice include/leveldb/Slice.h1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class LEVELDB_EXPORT Slice &#123; public: // 构造函数 创建空的slice // Create an empty slice. Slice() : data_(&quot;&quot;), size_(0) &#123; &#125; // 构造函数 使用d[0, n - 1] 构造 // Create a slice that refers to d[0,n-1]. Slice(const char* d, size_t n) : data_(d), size_(n) &#123; &#125; // 构造函数 使用C++ string 构造 // Create a slice that refers to the contents of &quot;s&quot; Slice(const std::string&amp; s) : data_(s.data()), size_(s.size()) &#123; &#125; // 构造函数 使用指定长度字符串指针 构造 // Create a slice that refers to s[0,strlen(s)-1] Slice(const char* s) : data_(s), size_(strlen(s)) &#123; &#125; // 采用默认拷贝构造，直接赋值 // Intentionally copyable. Slice(const Slice&amp;) = default; Slice&amp; operator=(const Slice&amp;) = default; // ========== 常用函数 =========== // 返回字符串指针 // Return a pointer to the beginning of the referenced data const char* data() const &#123; return data_; &#125; // 返回数据长度 // Return the length (in bytes) of the referenced data size_t size() const &#123; return size_; &#125; // 是否为空 // Return true iff the length of the referenced data is zero bool empty() const &#123; return size_ == 0; &#125; // 重载[]，通过slice[n]返回第n个字符 // Return the ith byte in the referenced data. // REQUIRES: n &lt; size() char operator[](size_t n) const &#123; assert(n &lt; size()); return data_[n]; &#125; // 清空 // Change this slice to refer to an empty array void clear() &#123; data_ = &quot;&quot;; size_ = 0; &#125; // 去除前缀n个字符 // Drop the first &quot;n&quot; bytes from this slice. void remove_prefix(size_t n) &#123; assert(n &lt;= size()); data_ += n; size_ -= n; &#125; // string 转化 // Return a string that contains the copy of the referenced data. std::string ToString() const &#123; return std::string(data_, size_); &#125; // 比较 // Three-way comparison. Returns value: // &lt; 0 iff &quot;*this&quot; &lt; &quot;b&quot;, // == 0 iff &quot;*this&quot; == &quot;b&quot;, // &gt; 0 iff &quot;*this&quot; &gt; &quot;b&quot; int compare(const Slice&amp; b) const; // 是否以slice x为前缀 // Return true iff &quot;x&quot; is a prefix of &quot;*this&quot; bool starts_with(const Slice&amp; x) const &#123; return ((size_ &gt;= x.size_) &amp;&amp; (memcmp(data_, x.data_, x.size_) == 0)); &#125; private: const char* data_; // 数据指针 size_t size_; // 数据长度&#125; 123456789101112131415161718192021// 重载==操作符，用于判断两个Slice是否相等inline bool operator==(const Slice&amp; x, const Slice&amp; y) &#123; return ((x.size() == y.size()) &amp;&amp; (memcmp(x.data(), y.data(), x.size()) == 0));&#125;// 重载!=操作符，用于判断两个Slice是否不等inline bool operator!=(const Slice&amp; x, const Slice&amp; y) &#123; return !(x == y);&#125;// 比较函数实现inline int Slice::compare(const Slice&amp; b) const &#123; const size_t min_len = (size_ &lt; b.size_) ? size_ : b.size_; int r = memcmp(data_, b.data_, min_len); if (r == 0) &#123; if (size_ &lt; b.size_) r = -1; else if (size_ &gt; b.size_) r = +1; &#125; return r;&#125; 简单使用 12345678910//声明定义一个空字符串Slice slice；//字符串指针初始化SliceSlice s1 = &quot;hello&quot;;const char* p=&quot;world&quot;Slice s2(p);//获取Slice的字符串s2.data();//获取Slice字符串的长度s2.size() ==注意：== 使用Slice时需要格外小心，因为Slice引用的外部数组是由Slice的使用者保证在Slice的生命周期内外部数组是有效的。比如下面的代码中存在bug： 123456Slice slice; if (...) &#123; std::string str = ...; slice = str; &#125; Use(slice); 当if语句的作用域结束时，str会被析构，slice指向的外部空间就不存在了。]]></content>
      <categories>
        <category>leveldb</category>
      </categories>
      <tags>
        <tag>leveldb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leveldb安装与使用]]></title>
    <url>%2F2018%2F06%2F22%2Fleveldb%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[leveldb Google C++ kv数据库。代码风格优秀。涉及到了skip list、内存KV table、LRU cache管理、table文件存储、operation log系统等。 安装下载1git clone https://github.com/google/leveldb.git 编译 安装123mkdir -p build &amp;&amp; cd buildcmake -DCMAKE_BUILD_TYPE=Release .. &amp;&amp; cmake --build .make &amp;&amp; make install 使用hello_leveldb.cc 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;cassert&gt;#include &lt;cstdlib&gt;#include &lt;string&gt;#include &lt;leveldb/db.h&gt;using namespace std;int main(void)&#123; leveldb::DB *db = nullptr; leveldb::Options options; // 如果数据库不存在就创建 options.create_if_missing = true; // 创建的数据库 /tmp/testdb leveldb::Status status = leveldb::DB::Open(options, &quot;/tmp/testdb&quot;, &amp;db); assert(status.ok()); string key = &quot;akey&quot;; string value = &quot;avalue&quot;; string gvalue; // Put leveldb::Status s = db-&gt;Put(leveldb::WriteOptions(), key, value); if (!s.ok()) &#123; // 写入失败 cout &lt;&lt; s.ToString() &lt;&lt; endl; return 0; &#125; // Get s = db-&gt;Get(leveldb::ReadOptions(), key, &amp;gvalue); cout &lt;&lt; (s.ok() ? gvalue : s.ToString()) &lt;&lt; endl; delete db; return 0;&#125; 编译1g++ hello_leveldb.cc -o test -lpthread -lleveldb 运行结果12# ./testavalue 只做了简单的put get操作，还有delete、snapshot等操作。]]></content>
      <categories>
        <category>leveldb</category>
      </categories>
      <tags>
        <tag>leveldb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F06%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to 老边’blog 创建文章1hexo new &quot;名称&quot; 标签 分类 描述12345tags: - 标签1 - 标签2categories： “分类”description： “描述” 创建标签页1hexo new page “tag_name” ##搭建 安装node.js安装hexo安装cmd 到指定目录1npm install -g hexo 初始化1hexo init 安装组件1npm install 体验1hexo s -g 关联github创建github项目1234567项目名为：用户名.github.io勾选 README进入settings可以看到 GitHub Pages配好ssh 修改 /_config.yml1234deploy: type: git repository: git@github.com:用户名/用户名.github.io.git branch: master 创建文章1hexo new post “文章名” 部署1234安装扩展npm install hexo-deployer-git --save部署hexo d -g Next/_config.yml123456789101112131415161718192021222324title: 标题subtitle: 副标题description: 描述author: 作者language: 语言（简体中文是zh-Hans）timezone: 网站时区（Hexo 默认使用您电脑的时区，不用写）index_generator: path: &apos;&apos; per_page: 5 order_by: -date archive_generator: per_page: 20 yearly: true monthly: truetag_generator: per_page: 10per_page: 5pagination_dir: pagetheme: next /themes/next/_config.yml1234567891011// 菜单menu: home: / || home archives: /archives/ || archive categories: /categories/ || th tags: /tags/ || tags // 样式 scheme: Piscesavatar: /images/avatar.jpg 搜索功能12345678 npm install hexo-generator-searchdb --save/_config.yml ：search: path: search.xml field: post format: html limit: 10000]]></content>
  </entry>
</search>
